package gparselib

import (
	"math"
	"testing"
)


func TestParseAny_NormalFunctionality(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	pn := NewParseNatural(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, 10)
	p := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	p.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pn.InPort)
	pn.SetOutPort(p.SubInPort)

	runTest(t, p, newData("empty", 0, ""), newResult(0, "", nil, 0), 0, 3)
	runTest(t, p, newData("no match", 0, " flow 3"), newResult(0, "", nil, 0), 0, 3)
	runTest(t, p, newData("match flow", 0, "flowabc"), newResult(0, "flow", nil, -1), 4, 0)
	runTest(t, p, newData("match 3", 2, "123noabc"), newResult(2, "3", uint64(3), -1), 3, 0)
	runTest(t, p, newData("match both", 3, "123flow3abc"), newResult(3, "flow", nil, -1), 7, 0)
}
func TestParseAny_Nested(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	pn := NewParseNatural(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, 10)
	pInner := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	pInner.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(pInner.SubInPort)
	pInner.AppendSubOutPort(pn.InPort)
	pn.SetOutPort(pInner.SubInPort)
	plFun := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "fun")
	pOuter := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	pOuter.AppendSubOutPort(plFun.InPort)
	plFun.SetOutPort(pOuter.SubInPort)
	pOuter.AppendSubOutPort(pInner.InPort)
	pInner.SetOutPort(pOuter.SubInPort)

	runTest(t, pOuter, newData("match flow", 3, "123flowabc"), newResult(3, "flow", nil, -1), 7, 0)
	runTest(t, pOuter, newData("match fun", 3, "123funabc"), newResult(3, "fun", nil, -1), 6, 0)
	runTest(t, pOuter, newData("match 3", 3, "1233abc"), newResult(3, "3", uint64(3), -1), 4, 0)
}
