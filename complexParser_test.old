package gparselib

import (
	"math"
	"testing"
)


func TestParseAll_NormalFunctionality(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	plNo := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "no")
	p := NewParseAll(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	p.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(plNo.InPort)
	plNo.SetOutPort(p.SubInPort)

	runTest(t, p, newData("empty", 0, ""), newResult(0, "", nil, 0), 0, 1)
	runTest(t, p, newData("no match", 0, " flow no"), newResult(0, "", nil, 0), 0, 1)
	runTest(t, p, newData("match flow", 0, "flowabc"), newResult(0, "", nil, 4), 0, 1)
	runTest(t, p, newData("match no", 3, "123noabc"), newResult(3, "", nil, 3), 3, 1)
	runTest(t, p, newData("match all", 3, "123flownoabc"), newResult(3, "flowno", []interface{}{nil, nil}, -1), 9, 0)
}
func TestParseAll_ManySubs(t *testing.T) {
	pl1 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "1")
	pl2 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "2")
	pl3 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "3")
	pl4 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "4")
	pl5 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "5")
	pl6 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "6")
	pl7 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "7")
	pl8 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "8")
	pl9 := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "9")
	p := NewParseAll(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })

	p.AppendSubOutPort(pl1.InPort)
	pl1.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl2.InPort)
	pl2.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl3.InPort)
	pl3.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl4.InPort)
	pl4.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl5.InPort)
	pl5.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl6.InPort)
	pl6.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl7.InPort)
	pl7.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl8.InPort)
	pl8.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pl9.InPort)
	pl9.SetOutPort(p.SubInPort)

	runTest(t, p, newData("match 9", 0, "1234567890"),
		newResult(0, "123456789", []interface{}{nil, nil, nil, nil, nil, nil, nil, nil, nil}, -1), 9, 0)
}
func TestParseAll_Nested(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	plNo := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "no")
	pInner := NewParseAll(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	plFun := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "fun")
	pOuter := NewParseAll(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	pInner.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(pInner.SubInPort)
	pInner.AppendSubOutPort(plNo.InPort)
	plNo.SetOutPort(pInner.SubInPort)
	pOuter.AppendSubOutPort(plFun.InPort)
	plFun.SetOutPort(pOuter.SubInPort)
	pOuter.AppendSubOutPort(pInner.InPort)
	pInner.SetOutPort(pOuter.SubInPort)

	runTest(t, pOuter, newData("match nested", 3, "123funflownoabc"),
		newResult(3, "funflowno", []interface{}{nil, []interface{}{nil, nil}}, -1), 12, 0)
}

func TestParseAny_NormalFunctionality(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	pn := NewParseNatural(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, 10)
	p := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	p.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(p.SubInPort)
	p.AppendSubOutPort(pn.InPort)
	pn.SetOutPort(p.SubInPort)

	runTest(t, p, newData("empty", 0, ""), newResult(0, "", nil, 0), 0, 3)
	runTest(t, p, newData("no match", 0, " flow 3"), newResult(0, "", nil, 0), 0, 3)
	runTest(t, p, newData("match flow", 0, "flowabc"), newResult(0, "flow", nil, -1), 4, 0)
	runTest(t, p, newData("match 3", 2, "123noabc"), newResult(2, "3", uint64(3), -1), 3, 0)
	runTest(t, p, newData("match both", 3, "123flow3abc"), newResult(3, "flow", nil, -1), 7, 0)
}
func TestParseAny_Nested(t *testing.T) {
	plFlow := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "flow")
	pn := NewParseNatural(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, 10)
	pInner := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	pInner.AppendSubOutPort(plFlow.InPort)
	plFlow.SetOutPort(pInner.SubInPort)
	pInner.AppendSubOutPort(pn.InPort)
	pn.SetOutPort(pInner.SubInPort)
	plFun := NewParseLiteral(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd }, "fun")
	pOuter := NewParseAny(func(data interface{}) *ParseData { return data.(*ParseData) },
		func(data interface{}, pd *ParseData) interface{} { return pd })
	pOuter.AppendSubOutPort(plFun.InPort)
	plFun.SetOutPort(pOuter.SubInPort)
	pOuter.AppendSubOutPort(pInner.InPort)
	pInner.SetOutPort(pOuter.SubInPort)

	runTest(t, pOuter, newData("match flow", 3, "123flowabc"), newResult(3, "flow", nil, -1), 7, 0)
	runTest(t, pOuter, newData("match fun", 3, "123funabc"), newResult(3, "fun", nil, -1), 6, 0)
	runTest(t, pOuter, newData("match 3", 3, "1233abc"), newResult(3, "3", uint64(3), -1), 4, 0)
}
